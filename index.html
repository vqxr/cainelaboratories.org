<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Caine Laboratories ¬∑ Biotech Rainforest</title>
  <!-- Google Fonts for a clean, futuristic yet organic feel -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Space Grotesk', sans-serif;
      color: white;
      background-color: #0a1f12;
    }

    /* canvas takes full screen, behind content */
    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    /* UI overlay ‚Äî centered, with glass effect */
    .content {
      position: absolute;
      z-index: 10;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none; /* allows clicks to pass to canvas if needed, but we keep it for text */
    }

    .center-panel {
      max-width: 800px;
      padding: 2.5rem 3rem;
      background: rgba(10, 30, 18, 0.25);
      backdrop-filter: blur(10px) brightness(0.8);
      -webkit-backdrop-filter: blur(10px) brightness(0.8);
      border: 1px solid rgba(120, 200, 120, 0.3);
      border-radius: 48px 16px 48px 16px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6), 0 0 30px rgba(60, 180, 100, 0.3);
      text-align: center;
      animation: floatIn 2s cubic-bezier(0.23, 1, 0.32, 1) forwards;
      pointer-events: none;
      transform-style: preserve-3d;
    }

    h1 {
      font-weight: 600;
      font-size: clamp(3rem, 8vw, 5rem);
      letter-spacing: 0.25em;
      margin: 0;
      text-transform: uppercase;
      background: linear-gradient(135deg, #c0f0c0, #a0e0a0, #d8ffd8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 20px #1f6f30, 0 0 40px #2b8c3a;
      animation: glowPulse 3s infinite alternate;
    }

    .sub {
      font-weight: 300;
      font-size: 1.6rem;
      letter-spacing: 0.3em;
      margin: 0.5rem 0 1rem;
      color: #ccffcc;
      text-shadow: 0 0 15px #1f6f30;
    }

    .tagline {
      font-size: 1.1rem;
      font-weight: 400;
      margin-bottom: 1.8rem;
      color: #b2e6b2;
      border-top: 1px dashed rgba(140, 220, 140, 0.6);
      border-bottom: 1px dashed rgba(140, 220, 140, 0.6);
      padding: 0.8rem 0;
      text-transform: uppercase;
      word-spacing: 0.5rem;
    }

    .tagline span {
      font-weight: 600;
      color: #ffffff;
      background: #1b4f2b70;
      padding: 0.2rem 0.6rem;
      border-radius: 40px;
      margin: 0 0.2rem;
    }

    .foot-note {
      font-size: 0.9rem;
      opacity: 0.75;
      letter-spacing: 0.2rem;
      margin-top: 2rem;
      color: #aae0aa;
    }

    @keyframes floatIn {
      0% { opacity: 0; transform: translateY(60px) scale(0.95); }
      100% { opacity: 1; transform: translateY(0) scale(1); }
    }

    @keyframes glowPulse {
      0% { text-shadow: 0 0 20px #1f6f30, 0 0 35px #2b8c3a; }
      100% { text-shadow: 0 0 35px #5fd87f, 0 0 60px #398048; }
    }

    /* small extra decorative elements via pseudo */
    .center-panel::before {
      content: "‚öóÔ∏èüå±";
      position: absolute;
      top: -20px;
      left: 20px;
      font-size: 2.2rem;
      opacity: 0.5;
      filter: drop-shadow(0 0 6px #aaffaa);
    }
    .center-panel::after {
      content: "üß™üçÉ";
      position: absolute;
      bottom: -20px;
      right: 20px;
      font-size: 2.2rem;
      opacity: 0.5;
      filter: drop-shadow(0 0 6px #aaffaa);
    }

    /* responsive adjustments */
    @media (max-width: 600px) {
      .center-panel { padding: 1.5rem 1rem; margin: 1rem; }
      h1 { letter-spacing: 0.15em; }
    }
  </style>
</head>
<body>
  <!-- 3D canvas injected here by Three.js -->
  <div id="canvas-container"></div>

  <!-- foreground content -->
  <div class="content">
    <div class="center-panel">
      <h1>CAINE LAB</h1>
      <div class="sub">¬∑  R A I N F O R E S T  ¬∑</div>
      <div class="tagline">
        <span>‚ö°</span> SUGAR CANE BIOTECH <span>‚ö°</span>
      </div>
      <div style="font-size:1.2rem; margin: 0.5rem 0;">
        üåø üß¨ üî¨ üå±
      </div>
      <div class="foot-note">ENGINEERING NATURE ¬∑ RESEARCH SITE LAUNCHING SOON</div>
    </div>
  </div>

  <!-- Three.js library from CDN -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.128.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.128.0/examples/jsm/controls/OrbitControls.js';

    // --- setup scene, camera, renderer with rich green/rainforest tones ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a2f1a); // deep jungle green
    // Add subtle fog to blend distant objects
    scene.fog = new THREE.Fog(0x0a2f1a, 10, 35);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(8, 5, 18);
    camera.lookAt(0, 2, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true; // for future if we add shadows (optional)
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- Controls disabled for static cool look (but we can rotate slightly automatically)
    // Instead we will rotate camera slowly with sin/cos for a subtle dolly effect

    // --- LIGHTING to create bioluminescent / rainforest canopy effect ---
    // Ambient fill
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    // Main directional light (simulating sun through leaves)
    const sunLight = new THREE.DirectionalLight(0xd5ffd5, 1.2);
    sunLight.position.set(5, 12, 8);
    sunLight.castShadow = false; // keep light for performance, shadows off
    scene.add(sunLight);

    // Backlight with greenish tint
    const backLight = new THREE.PointLight(0x6f9f6f, 0.8);
    backLight.position.set(-5, 4, -10);
    scene.add(backLight);

    // Colorful point lights to mimic bioluminescence or lab accents
    const light1 = new THREE.PointLight(0xaacc88, 0.6);
    light1.position.set(2, 3, 4);
    scene.add(light1);
    
    const light2 = new THREE.PointLight(0x88dd88, 0.5);
    light2.position.set(-3, 5, 6);
    scene.add(light2);

    // small floating "firefly" particles will be emissive later

    // --- GROUND with subtle texture / moss effect ---
    const groundGeometry = new THREE.CircleGeometry(30, 32);
    const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x1d4d1d, roughness: 0.8, emissive: 0x0a2a0a });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -0.2;
    ground.receiveShadow = false; // keep smooth
    scene.add(ground);

    // --- create decorative cane-like plants (3D sugarcane stalks with leaves) ---
    function createSugarCane(posX, posZ, scaleFactor = 1.0, hueShift = 0) {
      const group = new THREE.Group();
      
      // Stalk (segmented cylinder)
      const stalkMat = new THREE.MeshStandardMaterial({ 
        color: 0xaadd88, 
        emissive: 0x224422,
        roughness: 0.5,
        emissiveIntensity: 0.3
      });
      
      const segmentHeight = 0.8;
      const segmentCount = 5;
      for (let i = 0; i < segmentCount; i++) {
        const geom = new THREE.CylinderGeometry(0.25, 0.3, segmentHeight, 8);
        const segment = new THREE.Mesh(geom, stalkMat);
        segment.position.y = i * segmentHeight + segmentHeight/2;
        // add slight bend? no but we can rotate randomly later
        group.add(segment);
      }
      
      // Leaves (flat planes arranged)
      const leafMat = new THREE.MeshStandardMaterial({ color: 0x88cc44, emissive: 0x1a4a1a });
      for (let j = 0; j < 6; j++) {
        const leafGeom = new THREE.BoxGeometry(0.1, 0.8, 0.4); // long leaf
        const leaf = new THREE.Mesh(leafGeom, leafMat);
        leaf.position.y = segmentCount * segmentHeight - 0.2 + j * 0.3;
        leaf.rotation.z = 0.2 * (j % 2 === 0 ? 1 : -1);
        leaf.rotation.x = 0.3;
        leaf.rotation.y = j * 1.2;
        leaf.scale.set(1 + j*0.1, 1, 1);
        group.add(leaf);
      }
      
      // Tassel / flower-like top (glowing sphere)
      const topGlow = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 6),
        new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xaa6633 })
      );
      topGlow.position.y = segmentCount * segmentHeight + 0.2;
      group.add(topGlow);

      group.position.set(posX, 0, posZ);
      group.scale.set(scaleFactor, scaleFactor, scaleFactor);
      return group;
    }

    // Add a whole field of cane stalks, also with random rotations to look natural
    const canePositions = [
      [-2.5, -3], [3, -2], [-1, 2.5], [4.5, 1], [-4, 1.5], [0, -1.8], [2, 2.2], [-3.8, -2.2], [5, -1], [-5, -2],
      [1.5, 4], [-1.8, -4.5], [3.8, 3.2], [-3.2, 3.8], [0.5, -4], [4.2, -3.5], [-4.5, 0.2], [2.8, -1.2]
    ];
    
    canePositions.forEach(([x, z]) => {
      const cane = createSugarCane(x, z, 0.8 + Math.random()*0.5);
      cane.rotation.y = Math.random() * Math.PI;
      scene.add(cane);
    });

    // Add some smaller bushes / ferns (just simple shapes)
    for (let i = 0; i < 30; i++) {
      const bushMat = new THREE.MeshStandardMaterial({ color: 0x3d9f3d, emissive: 0x124412 });
      const bushGeom = new THREE.SphereGeometry(0.3 + Math.random()*0.4, 5);
      const bush = new THREE.Mesh(bushGeom, bushMat);
      const angle = Math.random() * Math.PI * 2;
      const radius = 4 + Math.random() * 6;
      bush.position.set(Math.cos(angle)*radius, 0.2, Math.sin(angle)*radius);
      bush.scale.set(1, 0.6 + Math.random()*0.5, 1);
      scene.add(bush);
    }

    // --- floating particles (fireflies / bioluminescent spores) ---
    const particleCount = 400;
    const particleGeom = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleColors = new Float32Array(particleCount * 3); // optional
    
    for (let i = 0; i < particleCount; i++) {
      // sphere distribution around center, with height range
      const r = 5 + Math.random() * 12;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.random() * Math.PI - Math.PI/2; // vertical spread
      
      const x = Math.cos(theta) * r * Math.cos(phi);
      const y = Math.sin(phi) * 4 + 3 + Math.random() * 4; // height from 1 to 8
      const z = Math.sin(theta) * r * Math.cos(phi);
      
      particlePositions[i*3] = x;
      particlePositions[i*3+1] = y;
      particlePositions[i*3+2] = z;
      
      // colors: greenish / yellowish / white
      const colorVal = 0.5 + Math.random() * 0.5;
      particleColors[i*3] = 0.6 + Math.random()*0.4;   // R
      particleColors[i*3+1] = 0.9 + Math.random()*0.5; // G
      particleColors[i*3+2] = 0.4 + Math.random()*0.6; // B
    }
    
    particleGeom.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    particleGeom.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));
    
    const particleMat = new THREE.PointsMaterial({ 
      size: 0.15,
      vertexColors: true,
      transparent: true,
      opacity: 0.9,
      blending: THREE.AdditiveBlending,
      map: createParticleTexture()
    });
    
    const particles = new THREE.Points(particleGeom, particleMat);
    scene.add(particles);

    // Helper to generate a soft circle texture for particles
    function createParticleTexture() {
      const canvas = document.createElement('canvas');
      canvas.width = 16;
      canvas.height = 16;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'white';
      ctx.beginPath();
      ctx.arc(8, 8, 6, 0, 2 * Math.PI);
      ctx.fill();
      ctx.globalCompositeOperation = 'source-atop';
      ctx.fillStyle = 'rgba(180,255,180,1)';
      ctx.beginPath();
      ctx.arc(8, 8, 4, 0, 2*Math.PI);
      ctx.fill();
      const tex = new THREE.CanvasTexture(canvas);
      return tex;
    }

    // Also add some bigger floating cubes / lab equipment vibe (but subtle)
    const floatingGadgets = new THREE.Group();
    for (let k = 0; k < 8; k++) {
      const geom = new THREE.IcosahedronGeometry(0.4, 0);
      const mat = new THREE.MeshStandardMaterial({ color: 0x99ee99, emissive: 0x224422, wireframe: true });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(
        (Math.random()-0.5)*10,
        2 + Math.random()*5,
        (Math.random()-0.5)*10
      );
      floatingGadgets.add(mesh);
    }
    scene.add(floatingGadgets);

    // --- Additional 3D effect: giant rainforest leaves in background? ---
    // We'll create a few large translucent leaf shapes
    const leafGroup = new THREE.Group();
    const leafMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x3d9f4d, 
      emissive: 0x0a2f0a,
      transparent: true, 
      opacity: 0.2,
      side: THREE.DoubleSide 
    });
    for (let l = 0; l < 10; l++) {
      const shape = new THREE.SphereGeometry(1.5, 5, 1);
      const leafMesh = new THREE.Mesh(shape, leafMaterial);
      leafMesh.scale.set(2.5, 0.2, 1.5);
      leafMesh.position.set(
        (Math.random()-0.5)*12,
        1 + Math.random()*6,
        (Math.random()-0.5)*15 - 5
      );
      leafMesh.rotation.x = Math.random() * Math.PI;
      leafMesh.rotation.y = Math.random() * Math.PI;
      leafMesh.rotation.z = Math.random() * Math.PI;
      leafGroup.add(leafMesh);
    }
    scene.add(leafGroup);

    // --- animation variables ---
    let clock = new THREE.Clock();

    // --- animation loop: rotate particles, move camera slightly, etc. ---
    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();
      const elapsedTime = performance.now() * 0.001; // seconds

      // Rotate particles slowly
      particles.rotation.y += 0.0005;
      particles.rotation.x += 0.0002;

      // Bobbing motion for floating gadgets
      floatingGadgets.children.forEach((child, idx) => {
        child.position.y += Math.sin(elapsedTime * 2 + idx) * 0.002;
        child.rotation.x += 0.01;
        child.rotation.y += 0.02;
      });

      // subtle camera dolly / orbit
      camera.position.x = 8 * Math.sin(elapsedTime * 0.1);
      camera.position.z = 15 + 2 * Math.cos(elapsedTime * 0.2);
      camera.position.y = 5 + Math.sin(elapsedTime * 0.3) * 0.5;
      camera.lookAt(0, 2, 0);

      renderer.render(scene, camera);
    }

    animate();

    // --- resize handler ---
    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Add some initial randomness to particle rotation
    particles.rotation.y = 1.2;
  </script>
</body>
</html>
